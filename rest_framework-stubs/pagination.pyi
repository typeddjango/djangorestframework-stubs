from typing import Any, Callable, Dict, List, NamedTuple, Optional, Sequence, Tuple, Type, Union

from django.core.paginator import Page, Paginator, _SupportsCount, _SupportsLen
from django.db.models import QuerySet
from django.http import HttpRequest
from django.views import View
from rest_framework.request import Request
from rest_framework.response import Response

def _positive_int(integer_string: str, strict: bool = ..., cutoff: Optional[int] = ...) -> int: ...
def _divide_with_ceil(a: int, b: int) -> int: ...
def _get_displayed_page_numbers(current: int, final: int) -> List[Optional[int]]: ...
def _get_page_links(
    page_numbers: Sequence[Optional[int]], current: int, url_func: Callable[[int], str]
) -> List[PageLink]: ...
def _reverse_ordering(ordering_tuple: Sequence[str]) -> Tuple[str, ...]: ...

class Cursor(NamedTuple):
    offset: int
    reverse: bool
    position: Optional[str]

class PageLink(NamedTuple):
    url: Optional[str]
    number: Optional[int]
    is_active: bool
    is_break: bool

PAGE_BREAK: PageLink = ...

class BasePagination:
    display_page_controls: bool = ...
    def get_paginated_response_schema(self, schema: Any): ...
    def get_paginated_response(self, data: Any) -> Response: ...
    def get_results(self, data: Dict[str, Any]) -> Any: ...
    def get_schema_fields(self, view: View) -> List[Any]: ...
    def get_schema_operation_parameters(self, view: Any): ...
    def paginate_queryset(self, queryset: QuerySet, request: HttpRequest, view: Optional[View] = ...): ...
    def to_html(self) -> str: ...

class PageNumberPagination(BasePagination):
    display_page_controls: bool = ...
    django_paginator_class: Type[Paginator] = ...
    invalid_page_message: str = ...
    last_page_strings: Sequence[str] = ...
    max_page_size: Optional[int] = ...
    page_query_description: str = ...
    page_query_param: str = ...
    page_size_query_description: str = ...
    page_size_query_param: Optional[str] = ...
    page_size: int = ...
    page: Optional[Page] = ...
    request: Optional[HttpRequest] = ...
    template: str = ...
    def get_page_size(self, request: Request) -> int: ...
    def get_next_link(self) -> Optional[str]: ...
    def get_previous_link(self) -> Optional[str]: ...
    def get_html_context(self) -> Dict[str, Any]: ...

class LimitOffsetPagination(BasePagination):
    count: Optional[int] = ...
    default_limit: int = ...
    limit_query_description: str = ...
    limit_query_param: str = ...
    limit: Optional[int] = ...
    max_limit: Optional[int] = ...
    offset_query_description: str = ...
    offset_query_param: str = ...
    offset: Optional[int] = ...
    request: Optional[HttpRequest] = ...
    template: str = ...
    def get_limit(self, request: Request) -> int: ...
    def get_offset(self, request: Request) -> int: ...
    def get_next_link(self) -> Optional[str]: ...
    def get_previous_link(self) -> Optional[str]: ...
    def get_html_context(self) -> Dict[str, Any]: ...
    def get_count(self, queryset: Union[_SupportsCount, _SupportsLen]) -> int: ...

class CursorPagination(BasePagination):
    base_url: Optional[str] = ...
    cursor_query_description: str = ...
    cursor_query_param: str = ...
    cursor: Optional[Cursor] = ...
    has_next: Optional[bool] = ...
    has_previous: Optional[bool] = ...
    invalid_cursor_message: str = ...
    max_page_size: Optional[int] = ...
    next_position: Optional[str] = ...
    offset_cutoff: int = ...
    ordering: Union[str, List[str], Tuple[str, ...]] = ...
    page_size_query_description: str = ...
    page_size_query_param: Optional[str] = ...
    page_size: int = ...
    page: Optional[List[Any]] = ...
    previous_position: Optional[str] = ...
    template: str = ...
    def get_page_size(self, request: Request) -> Optional[int]: ...
    def get_next_link(self) -> Optional[str]: ...
    def get_previous_link(self) -> Optional[str]: ...
    def get_ordering(self, request: Request, queryset: QuerySet, view: View) -> Tuple[str, ...]: ...
    def decode_cursor(self, request: Request) -> Optional[Cursor]: ...
    def encode_cursor(self, cursor: Cursor) -> str: ...
    def _get_position_from_instance(self, instance: Any, ordering: Sequence[str]) -> str: ...
    def get_html_context(self) -> Dict[str, str]: ...
